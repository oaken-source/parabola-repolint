'''
this module provides the linter orchestrator
'''

import importlib
import pkgutil
import logging
import datetime
import socket
import enum


# pylint: disable=too-few-public-methods,no-self-use
class LinterCheckBase():
    ''' a base class for linter checks '''

    def __init__(self, linter, cache):
        ''' a default constructor '''
        self._linter = linter
        self._cache = cache

    def format(self, issues):
        ''' a default formatter for found issues '''
        res = []
        for issue in issues:
            res.append('    ' + issue[0] % issue[1:])
        return "\n".join(sorted(res))



class LinterIssue(Exception):
    ''' raised by linter checks to indicate problems '''


class LinterCheckType(enum.Enum):
    ''' possible linter check types '''
    PKGBUILD = 1
    PKGFILE = 2
    PKGENTRY = 3
    SIGNING_KEY = 4
    MASTER_KEY = 5


def _is_linter_check(cls):
    ''' indicate whether a given anything is a linter check class '''
    return (isinstance(cls, type)
            and issubclass(cls, LinterCheckBase)
            and cls != LinterCheckBase)


def _load_linter_checks_from(package_name):
    ''' load a list of classes from the given package '''
    package = importlib.import_module(package_name)

    result = []
    for _, name, _ in pkgutil.walk_packages(package.__path__):
        name = package.__name__ + '.' + name

        logging.debug('loading linter checks from "%s"', name)
        module = importlib.import_module(name)

        for cls in module.__dict__.values():
            if _is_linter_check(cls):
                logging.debug('loaded linter check "%s"', cls.name)
                result.append(cls)

    return result


class Linter():
    ''' the master linter class '''

    def __init__(self, repo_cache):
        ''' constructor '''
        self._checks = _load_linter_checks_from('parabola_repolint.linter_checks')
        self._enabled_checks = []
        self._issues = {}

        self._cache = repo_cache

        self._start_time = None
        self._end_time = None

    @property
    def checks(self):
        ''' return the names of all supported linter checks '''
        return map(lambda c: c.name, self._checks)

    def register_repo_cache(self, cache):
        ''' store a reference to the repo cache '''
        self._cache = cache

    def load_checks(self, checks):
        ''' initialize the set of enabled linter checks '''
        self._start_time = datetime.datetime.now()

        self._enabled_checks = [c(self, self._cache) for c in self._checks if c.name in checks]
        logging.debug('initialized enabled checks %s', self._enabled_checks)

    def run_checks(self):
        ''' run the previuosly initialized enabled checks '''
        check_funcs = {
            LinterCheckType.PKGBUILD: self._run_check_pkgbuild,
            LinterCheckType.PKGENTRY: self._run_check_pkgentry,
            LinterCheckType.PKGFILE: self._run_check_pkgfile,
            LinterCheckType.SIGNING_KEY: self._run_check_signing_key,
            LinterCheckType.MASTER_KEY: self._run_check_master_key,
        }

        for check_type in LinterCheckType:
            check_func = check_funcs[check_type]
            for check in [c for c in self._enabled_checks if c.check_type == check_type]:
                self._issues[check] = []
                logging.info('running check %s', check)
                check_func(check)

        self._end_time = datetime.datetime.now()

    def _run_check_pkgbuild(self, check):
        ''' run a PKGBUILD type check '''
        for pkgbuild in self._cache.pkgbuilds:
            self._try_check(check, pkgbuild)

    def _run_check_pkgentry(self, check):
        ''' run a PKGENTRY type check '''
        for pkgentry in self._cache.pkgentries:
            self._try_check(check, pkgentry)

    def _run_check_pkgfile(self, check):
        ''' run a PKGFILE type check '''
        for pkgfile in self._cache.pkgfiles:
            self._try_check(check, pkgfile)

    def _run_check_signing_key(self, check):
        ''' run a SIGNING_KEY type check '''
        for key in self._cache.key_cache.values():
            self._try_check(check, key)

    def _run_check_master_key(self, check):
        ''' run a MASTER_KEY type check '''
        for key in self._cache.keyring:
            self._try_check(check, key)

    def _try_check(self, check, *args, **kwargs):
        ''' run a check and catch any LinterIssue '''
        try:
            check.check(*args, **kwargs)
        except LinterIssue as i:
            self._issues[check].append(i.args)

    def format(self):
        ''' return a formatted string of the linter issues '''
        now = self._end_time.strftime("%Y-%m-%d %H:%M:%S")
        out = '''
==============================================================================
This is an auto-generated list of issues in the parabola package repository.
Generated by parabola-repolint on %s at %s
==============================================================================
''' % (socket.gethostname(), now)

        for check in self._enabled_checks:
            if self._issues[check]:
                header = '%s:\n%s' % (check.header, '-' * (len(check.header) + 1))
                out += '\n\n\n%s\n%s\nissues:\n' % (header, check.__doc__)
                out += check.format(self._issues[check])
        return out

    def short_format(self):
        ''' return a (short) formatted string of the linter issues '''
        now = self._end_time.strftime("%Y-%m-%d %H:%M:%S")
        out = 'parabola-repolint check at %s' % now

        for check in self._enabled_checks:
            if self._issues[check]:
                out += '\n  %s: %i' % (check.header, len(self._issues[check]))
        out += '\ntotal issues: %i' % self.total_issues

        return out

    @property
    def total_issues(self):
        ''' produce the total number of found issues '''
        res = 0
        for check in self._enabled_checks:
            res += len(self._issues[check])
        return res

    @property
    def start_time(self):
        ''' produce the start time of the linter '''
        return self._start_time

    @property
    def end_time(self):
        ''' produce the end time of the linter '''
        return self._end_time
